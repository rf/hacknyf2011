
import os.path, re, datetime

reDefine = re.compile(r'define\s*\(\s*\[(.*?)\]', re.M|re.DOTALL)
reStyle = re.compile(r'style\s*\(\s*(.*?)\s*\)', re.M|re.DOTALL)
reStr = re.compile(r'[\'"](.*?)[\'"]')
rePragma = re.compile(r'^\s*"pragma\s+(.*?)\s*"\s*;?\s*$', re.M)

# **************************************************************************************************

class Loader(object):
    staticDirName = 'static'
    yuiJarPath = '/usr/local/java/yuicompressor-2.4.2.jar'
    
    def __init__(self, paths):
        self.searchPaths = paths
        self.cache = {}
        self.apps = {}
        self.transientExtensions = []
        
    def load(self, url, compress=False, munge=True):
        parts = url.split('/')
        if parts[1] == 'static':
            path = self.searchStatic('/'.join(parts[2:]))
            if path:
                return path, self.loadSource(path, compress, munge, compress)
        elif parts[1] == 'js':
            path = self.searchScript('/'.join(parts[2:]))
            if path:
                return path, self.loadSource(path, compress, munge, compress)
        else:
            return self.load('/'.join(parts[1:]), compress, munge)
            
        return None,None

    def loadSource(self, path, compress=False, munge=True, useCache=False):
        if useCache:
            sourceTime = datetime.datetime.fromtimestamp(os.stat(path).st_mtime)
            if path in self.cache:
                source,cacheTime = self.cache[path]
                if sourceTime <= cacheTime:
                    return source

        if compress:
            nomunge = '--nomunge' if not munge else ''
            command = 'java -jar %s %s %s' % (self.yuiJarPath, nomunge, path)
            print command
            from subprocess import Popen, PIPE
            pipe = Popen(command, shell=True, stdout=PIPE)
            stdout = pipe.stdout
            source = stdout.read()

            self.cache[path] = (source,sourceTime)
        else:
            f = file(path)
            source = f.read()
            f.close()
        
        return source
    
    def searchApp(self, path):
        if path in self.apps:
            return self.apps[path]
        elif self.searchScript(path):
            from App import App
            app = App(path, self)
            self.apps[path] = app
            return app

    def searchScript(self, path):
        """ Searches for a JavaScript module.
            
            Returns an absolute path or None if not found."""

        path = self.__securePath(path)
        base,ext = os.path.splitext(path)
        if not ext:
            path = '%s.js' % path
        # elif ext != '.js':
        #     return
        
        for basePath in self.searchPaths:
            absolutePath = os.path.join(basePath, path)
            if os.path.isfile(absolutePath):
                return absolutePath

    def searchStatic(self, path):
        """ Searches for a file in a static directory.
            
            Returns an absolute path or None if not found."""
        
        path = self.__securePath(path)
        parts = path.split('/')
        if not parts:
            return
        
        rootModuleName = parts[0]
        rootFileName = '%s.js' % rootModuleName
        relativePath = '/'.join(parts[1:])
        
        for basePath in self.searchPaths:
            scriptPath = os.path.join(basePath, rootFileName)
            if not os.path.isfile(scriptPath):
                dirPath = os.path.join(basePath, rootModuleName)
                if os.path.isdir(dirPath):
                    basePath = dirPath
                else:
                    continue
            
            if relativePath:
                absolutePath = os.path.join(basePath, self.staticDirName, relativePath)
            else:
                absolutePath = os.path.join(basePath, self.staticDirName)
            if os.path.exists(absolutePath):
                return absolutePath

    def traceDependencies(self, moduleName, skipDebug=False):
        moduleMap = {}
        styleMap = {}
        self.__trace(moduleName, skipDebug, moduleMap, styleMap)
        return moduleMap, styleMap
        
    def __trace(self, moduleName, skipDebug, moduleMap=None, styleMap=None):
        if moduleName not in moduleMap:
            path = self.searchScript(moduleName)
            if path:
                f = file(path)
                source = f.read()
                f.close()

                pragmas = moduleMap[moduleName] = {
                    'debug': not self.__shouldTrace(moduleName)
                }
                for pragma in rePragma.findall(source):
                    pragmas[pragma] = 1
                
                if not skipDebug or not pragmas.get('debug'):
                    m = reDefine.search(source)
                    if m:
                        depsArray = m.groups()[0]
                        parts = depsArray.split(',')
                        for depString in parts:
                            m = reStr.search(depString)
                            if m:
                                depName = m.groups()[0]
                                absoluteName = self.normalizeName(depName, moduleName)
                                self.__trace(absoluteName, skipDebug, moduleMap, styleMap)

                for pathString in reStyle.findall(source):
                    m = reStr.search(pathString)
                    if m:
                        staticName = m.groups()[0]
                        absoluteName = self.normalizeName(staticName, moduleName)
                        styleMap[absoluteName] = {}
 
    def normalizeName(self, name, baseName):
        if name and name[0] == '.': 
            # Relative paths inside of root modules are contained within the module, not its parent
            if baseName.find('/') == -1:
                baseName = '%s/' % baseName
            return os.path.normpath(os.path.join(baseName, name))
        else:
            return name
    
    def __securePath(self, path):
        newPath = ''
        for part in path.split('/'):
            if not part:
                continue

            drive, part = os.path.splitdrive(part)
            head, part = os.path.split(part)
            if part in (os.curdir, os.pardir):
                continue

            newPath = os.path.join(newPath, part).replace('\\', '/')
        return newPath

    def __shouldTrace(self, name):
        base,ext = os.path.splitext(name)
        return ext not in self.transientExtensions
